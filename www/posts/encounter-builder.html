
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title></title>
  <link rel="shortcut icon" type="static/image/png" href="images/favicon-16x16.png" />
  <link rel="stylesheet" type="text/css" href="/static/css/normalize.min.css">
  <link rel="stylesheet" type="text/css" href="/static/css/styles.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&family=Source+Sans+Pro&display=swap"
    rel="stylesheet">
  <link rel="alternate" type="application/rss+xml" title="" href="/rss">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="A Developer blog for Chris Hughes. Specializes in JavaScript, Rust, Web development, SQL" />
  <script src="https://unpkg.com/htmx.org@1.9.10"
    integrity="sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC" crossorigin="anonymous" defer>
    </script>
  <script src="/static/js/menu.js" defer></script>
  <script src="/static/js/colors.js" defer></script>
</head>


<header class="desktop">
  <nav>
    <a href="/about" hx-get="/cards" hx-swap="innerHTML" hx-push-url="/" hx-target="#contentDiv">
      <h2>Chris Hughes dot Dev</h2>
    </a>
    <div class="social-links">
      <a href="/about" hx-get="/resume" hx-swap="innerHTML" hx-push-url="/resume"
        hx-target="#contentDiv">Resume</a>
      <a href="https://github.com/naokontai" target="_blank" rel="noopener noreferrer">
        GitHub
      </a>
      <a href="/about" hx-get="/about" hx-swap="innerHTML" hx-push-url="/about" hx-target="#contentDiv">About</a>
      <a href="mailto: chris@chris-hughes.dev">
        <i class="fa-solid fa-envelope"></i>
      </a>
      <a href="/rss">
        <i class="fa-solid fa-rss"></i>
      </a>
      <button id="theme-toggle">
        <i id="moon" class="fa-regular fa-moon"></i>
        <i id="bulb" class="fa-regular fa-lightbulb"></i>
      </button>
    </div>
  </nav>
</header>
<header class="mobile">
  <nav>
    <a href="/cards" hx-get="/cards" hx-swap="innerHTML" hx-push-url="/" hx-target="#contentDiv">
      <h2>Chris Hughes.Dev</h2>
    </a>
    <a href="javascript:void(0);" onclick="handleSocial()">
      <i class="fa fa-bars menu"></i>
    </a>
  </nav>
</header>
<div id="social-menu" style="display: none;">
  <div class="mobile-social">
    <a href="/rss">
      <i class="fa-solid fa-rss"></i>
    </a>
    <a href="mailto: chris@chris-hughes.dev">
      <i class="fa-solid fa-envelope"></i>
    </a>
    <a href="https://github.com/naokontai" target="_blank" rel="noopener noreferrer">
      <i class="fa-brands fa-github"></i>
    </a>
    <a href="/resume" hx-get="/resume" hx-swap="innerHTML" hx-push-url="/resume" hx-target="#contentDiv">
      <i class="fa-regular fa-address-card"></i>
    </a>
    <button id="theme-toggle-mobile">
      <i id="moon-mobile" class="fa-regular fa-moon"></i>
      <i id="bulb-mobile" class="fa-regular fa-lightbulb"></i>
    </button>
  </div>
</div>

<div id="contentDiv" class="contentDiv">

<p>
  <title>Encounter Builder</title>
</p>
<summary>
  An encounter builder for pathfinder 2E for creating balanced encounters built with Svelte and Rust.
</summary>
<h1>Encounter Builder</h1>
<small class="date">Published: Fri, 09 Feb 2024 01:19:54-4:00</small>
<br>
<small class="tech">Rust | Svelte | PostgreSQL</small>

<p>
  <a href="https://alembichead.com/encounter-builder">PF2e Encounter Builder</a> is a Rust and Svelte web application
  that uses a Rust API and a Svelte front-end. The web application is designed to dynamically create encounters for a
  popular table top roll playing game called Pathfinder 2e. Using an HTML form on the front-end, users are able to
  configure their search constraints and then <code>fetch()</code> sends a query data to the Rust API. The rust back-end
  calculates the encounter budget and other query parameters which is then used to query a PostgreSQL database and send
  it as JSON back to the client. Additionally, to get the dataset, I built a web scraper in Rust to obtain and build the
  SQL database from an open source document that I will cover in another blog post.
</p>
<div id="outline-container-orga5b7348" class="outline-2">
  <h2 id="orga5b7348">Why Rust</h2>
  <div class="outline-text-2" id="text-orga5b7348">
    <p>
      I had initially considered using TypeScript for this project because I knew that I wanted a type system.
      Calculating the budget requires enough calculations that I knew that using vanilla JavaScript would create major
      headaches and be prone to bugs. I ended up settling on Rust because I thought that it would be able to handle
      manipulating the data structures more efficiently and make the app feel snappier. I don't know what kind of
      performance gain, if any, this actually gives me and benchmarking it would require me to rewrite large portions of
      the API in JavaScript.
    </p>

    <p>
      While my initial decision was driven by pure speculation about Rust vs. JavaScript performance, using Rust had
      other advantages that I did not anticipate.
    </p>
  </div>
  <div id="outline-container-org396985e" class="outline-3">
    <h3 id="org396985e">Separation of Concerns</h3>
    <div class="outline-text-3" id="text-org396985e">
      <p>
        This project helped me gain new insights into OOP. I had to solve the problem of how to effectively translate
        between the Rust, JavaScript, SQL and Json methods for working with objects and communicate between the
        JavaScript iteration on the client and the Rust iteration of the same concepts on the server. On the server I
        used structs to store and manipulate the data and enums to control the state of the objects based on data from
        the client side as well as query results from the PostgreSQL database. On the client-side I used a class based
        approach to represent the objects and setter methods for retrieving new data from the server. I used the state
        management tools built into Svelte in conjunction with an HTML form to manage state on the client side. The
        client-side required extra attention to validation in order to ensure that the server was obtaining valid data
        for instantiating the structs and safely querying the database.
      </p>

      <p>
        A further insight I gained into OOP was the effect that using two programming languages and separate processes
        on the server had on coupling. While the concepts of a monster and an encounter needed to be represented to the
        client and on the server to query the database and generate an HTTP response for the client, the methods
        required for these tasks were entirely different. Using two processes promoted a greater degree of encapsulation
        and an extra layer of validation on the server-side where the data needed to adhere to Rust's rigid typing
        system. One drawback to this approach, how the two processes communicate, was mitigated to a large degree by the
        fact that the data was being translated into HTTP requests and responses regardless.
      </p>

      <p>
        While in many cases it can make code more maintainable having it in a common language, if the back-end logic
        were written in JavaScript and existed in the same Sveltekit application, the temptation to couple would be
        huge. This project is small enough that would probably not be critical, but in large projects this separation of
        concerns could have OOP advantages.
      </p>

      <p>
        There are a few minor disadvantages that I confronted. Switching between languages requires, or at least
        strongly encourages, a context switching in terms of naming conventions. This could create confusion over what
        variables mean as they are in a slightly different format, and requires some thinking about at what point you
        want to change the naming conventions when sending the data between the front-end and back-end. I don't think
        this is a major concern, but it's perhaps worth considering.
      </p>

      <p>
        The other disadvantage I encountered was process management. Using Rust and JS together requires me to run and
        maintain two separate processes on the server. The overhead of the Rust process is negligible in terms of
        resources, but it separates the logging of the two processes. This can be viewed as a disadvantage or as an
        advantage as it keeps my front-end and back-end logs completely separate making identifying where problems are
        arising easier.
      </p>
    </div>
  </div>
</div>
<div id="outline-container-org5d169fc" class="outline-2">
  <h2 id="org5d169fc">Testing</h2>
  <div class="outline-text-2" id="text-org5d169fc">
    <p>
      In order to test the app, I am using three different overall groups of tests. First, I am running smaller scale
      unit tests on functions, second an integration test that tested the back-end as a whole, but bypassing the
      network, and finally I wrote a separate test app with Node, <a href="https://pptr.dev/">Puppeteer</a> and <a
        href="https://mochajs.org/">Mocha</a>. The latter two tests ended up being the most helpful in finding bugs so
      far.
    </p>

    <p>
      My strategy for the integration test was to begin and end with the two structs that implemented the serde json
      <code>#[derive(Deserialize)]</code> and <code>#[derive(Serialize)]</code> macros that deserialized the URL query
      string coming in from the client and then serialized the json response back to the client. The goal was the
      isolate just the back-end logic, ensure that it was correct so that I could rule that out when doing the end to
      end tests that tested the entire route from client, server, database, server and then back to the client. Any
      remaining issues then should lay with either the network or the front-end. This test aims to iterate through as
      many data combinations as possible and isolated some bugs that cropped up in edge cases.
    </p>

    <p>
      Once I had isolated bugs with the server side integration test, I used puppeteer to enter similar data to what I
      had hard coded into the tests on the server side in the integration test. I then captured the json with puppeteer:
    </p>

    <div class="org-src-container">
      <pre class="src src-javascript"> <span style="color: #6f80ff; font-weight: bold;">await</span>
        page.waitForResponse<span style="color: #379cf6;">(</span><span
          style="color: #6f80ff; font-weight: bold;">async</span> response =&gt; <span style="color: #d0730f;">{</span>
        <span style="color: #6f80ff; font-weight: bold;">return</span> <span style="color: #6f80ff;">(</span><span
          style="color: #6f80ff; font-weight: bold;">await</span> response.text<span
          style="color: #df805f;">()</span><span style="color: #6f80ff;">)</span>.startsWith<span
          style="color: #6f80ff;">(</span><span style="color: #df805f;">'{"id"'</span><span
          style="color: #6f80ff;">)</span>;
        <span style="color: #d0730f;">}</span><span style="color: #379cf6;">)</span>;
      </pre>
    </div>

    <p>
      <code>{"id"</code> being the first part of the json response. Once I had the json I used the mocha library to test
      the data.
    </p>

    <p>
      I ran into a rather frustrating issue with puppeteer that was a valuable lesson. I kept getting incorrect data
      back from the server when running the Node end to end tests, but after some time I realized that, after I loaded
      the page, the select input that I was trying to manipulate did not exist yet. It wasn't causing an error, but the
      form was not being submitted correctly. I used <code>await page.waitForNetworkIdle();</code> in order to ensure
      that the page was fully loaded and then submitted the form data and the tests passed as expected.
    </p>
  </div>
</div>


</div>

<footer>
  <div>
    <a href="/">Home</a>
    <a href="mailto: chris@chris-hughes.dev">Email</a>
    <div>
      <small>&copy; Chris Hughes 2025</small>
    </div>
  </div>
</footer>

</html>
